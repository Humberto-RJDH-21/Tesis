\chapter{Apéndice B}
\label{Ch:ApenB}


El objetivo de este apéndice es de mostrar los algoritmos

\section{Algoritmos del PID \emph{wavelet} empleados para la simulación}
\subsection{MATLAB}

\begin{matlab}{Función de descomposición}\label{Algoritmo:FWD}
\\
function $[a0,w0] =$ FWD$(s)$\\
\% Filtros de Descomposición y Reconstrucción\\
$g0 = [0.68301; 1.18301; 0.31699; -0.18301];$ \\
$k = [0; 1; 2; 3];$\\
$g1 = flipud(g0).*(-1).^{\wedge} k;$\\
$h0 = flipud(g0) / 2;$\\
$h1 = flipud(g1) / 2;$\\
    \% Proceso de Descomposición\\
    \% Sólo un nivel de Descomposición\\
\\
    $x = conv(s, h0);$\\
    $a0 = x(1:2:length(x));$~~~~\% muestreo a dos\\
    $x = conv(s,h1);$\\
    $w0 = x(1:2:length(x));$~~~~\% muestreo a dos
\end{matlab}

\section{Algoritmo del filtro \emph{wavelet}.}

Los algoritmos fueron programados en un lenguaje de programación
en $C++$...

\begin{algoritmo}{wavelet.h}\label{algwaveleth}
\\
// wavelet.h\\
// Función para la el analisis multirresolución\\
$\sharp$ define Mbuff 64    // tamaño del buffer\\
$\sharp$ define Nfilt   14 // tamaño del filtro\\
/* \\
// Filtro con Dauechies (m=2)\\
float G0[~] = \{ 0.6830127, 1.1830127, 0.31698729, -0.1830127 \};
// h sintesis\\
float G1[~] = \{ G0[3], -G0[2], G0[1], -G0[0] \}; // g sintesis\\
float H0[~] = \{ G0[3]/2, G0[2]/2, G0[1]/2, G0[0]/2\}; // h descomposición\\
float H1[~] = \{ G1[3]/2, G1[2]/2, G1[1]/2, G1[0]/2\}; // g descomposición\\
*/ \\
// Filtro con Dauechies (m=7)\\
float G0[~] = \{0.0778521, 0.396539, 0.729132, 0.469782,
-0.143906, -0.224036,\\
0.0713092, 0.0806126, -0.0380299, -0.0165745, 0.012551,
0.00042957,\\
-0.0018016, 0.00035371\}; // h sintesis\\
float G1[~] = \{G0[13], -G0[12], G0[11], -G0[10], G0[9], -G0[8],\\
G0[7], -G0[6], G0[5], -G0[4], G0[3], -G0[2],\\
G0[1], -G0[0]\}; // g sintesis\\
float H0[~] = \{G0[13]/2, G0[12]/2, G0[11]/2, G0[10]/2, G0[9]/2,
G0[8]/2,\\
G0[7]/2, G0[6]/2, G0[5]/2, G0[4]/2, G0[3]/2, G0[2]/2,\\
G0[1]/2, G0[0]/2\}; // h descomposición\\
float H1[~] = \{G1[13]/2, G1[12]/2, G1[11]/2, G1[10]/2, G1[9]/2,
G1[8]/2,\\
G1[7]/2, G1[6]/2, G1[5]/2, G1[4]/2, G1[3]/2, G1[2]/2,\\
G1[1]/2, G1[0]/2\}; // g descomposición\\
//---------------------------------------\\
float VectBuff[Mbuff];\\
float VectX[Mbuff];\\
float VectY[Mbuff];
float VectZ[Mbuff];\\
int Vectl[Mbuff]; float wave=0;\\
//***********************************\\
// Inicializando Vectores\\
//***********************************\\
void tempsinit(~) \{\\
    for(int w=0; w<2*Mbuff; w++)\\
        temps[w] = 0;\}\\
void Vectlinit(int LV) \{\\
    Vectl[0] = Mbuff;\\
    for (int w=1; w<LV+1; w++)\\
        Vectl[w] = (Vectl[w-1]+Nfilt)/2;\}\\
void VectBuffinit(~) \{\\
    for(int w=0; w<Mbuff; w++)\\
        VectBuff[w] = 0;\}\\
void VectXinit(~) \{\\
    for(int w=0; w<Mbuff; w++)\\
        VectX[w] = 0;\}\\
void VectYinit(~) \{\\
    for(int w=0; w<Mbuff; w++)\\
        VectY[w] = 0;\}\\
void VectZinit(~) \{\\
    for(int w=0; w<Mbuff; w++)\\
        VectZ[w] = 0;\}\\
//*********************************************************
\end{algoritmo}
